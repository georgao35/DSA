# Hacker

## 设计思路

利用哈希的思想,根据算得的密文对明文进行哈希.对于所有可能的字符串所构成的集合,对所有字符串都获得其密文,并根据密文模指数10000103的余数来进行哈希,储存在哈希表中.

### 数据结构

```c++
struct node{
    ll str; unsigned int hashResult; int next;
};
```

程序采用了开放的哈希表来解决冲突,并设计了哈希表中的结点数据结构如图,包括:`long long`类型的整数`str`,用来代表最长为八位的字符串;`unsigned int`类型的`hashResult`,用来储存该字符串对应的密文;最后储存了一个整型`next`用来代表同一个桶中的下一个结点.

不同桶对应着密文取模后的余数.

### 算法设计

为了用更少的时间和空间来区分字符串,程序将字符串看作是19进制、最高为8位的长整数,这样可以更好地对字符串进行判断、赋值等操作.

首先对$D_1$中的所有字符串进行计算,并加入到哈希表中.之后只需要加入长度为6、7、8的新子串.

对于一个密文,查找的方法是取模到对应的桶中.若桶是空的,那么查找失败;若不是空的,则对桶中的元素进行查找,如果查找到且仅有一个就是答案;若有多个就是重复.

每次查找成功就将首字符记录下来,并不断进行插入.插入时,对桶中的元素进行遍历查找,防止出现重复的情况.此时用字符串对应的长整数可以更快速地进行判断.

## 遇到问题

1. 最初用18进制整数来代表字符串,但这样就难以区分0123和123.在改为19进制后解决了这一问题

## 复杂度分析

1.  散列表的插入、查询等操作平均为$O(1)$,因此整个操作下来,每次查询加上插入3次等操作,最多也是常数,因此总体复杂度为$O(n)$.
2. 在空间上,选择了10000103作为散列表的长度.由于最多可能有$18+18^2+\cdots+18^5+3\times n$个字符串,因此散列表中的元素最多有5000000左右,是$O(n)$量级的.因此总体上,用$O(n)$的空间就可以完成题目.

