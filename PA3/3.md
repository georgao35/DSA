# kth

## 设计思路

利用堆来解决问题.首先对`x[],y[],z[]`分别进行排序.将排序后的第一个元素(1,1,1)放入堆中.将堆顶的元素弹出后,将其周围的元素放入堆中,以此不断进行,进行k次后就获得了和的大小第k大的数对和.

### 数据结构

```c++
template <class T> class Heap{};
```

实现了一个模版类小顶堆.为了能够使点之间进行比较,利用了提供的compare函数来实现了判断两个排序后的x,y,z坐标的和的大小.

在排序时,使用归并排序进行排序.为了比较同一个数组内的元素大小,利用compare函数.在调用compare函数时,将其他两个数组的秩固定,就可以用来比较这一个数组内的元素大小.

为了保证同一个点不被入堆两次,我们可以这样安排入堆的策略:当点的y、z坐标为1时,其三个相邻的更大的点都放入堆中;若只有z坐标为1,则将其y+1、z+1的两个相邻的点放入堆中;其他的情况只将z+1的点放入堆中.可以这样做的原因是因为已经将`x[],y[],z[]`三个数组排好序,有序就使得当(x,y,z)点进入堆时,(x-1,y,z),(x,y-1,z),(x,y,z-1)都应该进入到堆中.这样,并不需要一次将堆顶的所有方向的相邻点都放到堆中:它的相邻点一定会因为是其他的点的相邻点而被放入堆中.这样就可以按照上述的方法进堆.

## 遇到问题



## 复杂度分析

1. 排序时需要的时间复杂度$O(n\log n)$.对于堆,堆中的元素最多不会超过3k,因此每一次的复杂度上界$O(\log k)$.因此总共需要时间复杂度$O(n\log n+k\log k)$.
2. 在空间上,三个排序好的数组所用空间$O(n)$.由于堆中的元素最多不会超过3k,因此堆的空间复杂度$O(k)$.因此总体的空间复杂度为线性$O(n+k)$.