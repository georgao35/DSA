# Component

## 设计思路

为求出联通支中权值第k大的权值，维护一个元素个数不大于k的小根堆。这样当元素为k时，小根堆的堆顶的值就是第k大的值；若元素小于k时，说明联通支中的点的个数尚不达k个，此时输出-1即可。

### 数据结构

由于加入的边所连接的两点不一定是否在同一个联通支中，因此采用了并查集的数据结构用来判断两个点是否在同一联通支中。再加入一条边后，首先利用并查集判断两个点是否在同一个联通支中。如果两个结点不在同一个联通支中，则在并查集中将其合并，并将两个联通支对应的堆合并。

为了能够使堆快速合并，采用了左式堆的数据结构，使得合并的操作的复杂度达到$O(\log n)$。

```c++
class LeftHeap{
    Node* _root; int _size;
    LeftHeap(): _size(1){}
    int getMin();
    int delMin();
};
```

在最初，将每个点都视为一个左式堆，存储在一个长度为n的数组中。每个联通支所对应的堆的秩为并查集中联通支的代表元，可以通过`unionFind.find(u)`找到这个代表元。若联通支需要合并，则将其对应的左式堆进行合并，合并到代表元的堆上，并且更新堆的大小，将多于`k`的全部弹出。

### 算法设计

当要查询时，根据并查集可以得到所在联通支的代表元，根据代表元得到该联通支的堆，并对尺寸进行判断：当元素为k时，小根堆的堆顶的值就是第k大的值；若元素小于k时，说明联通支中的点的个数尚不达k个，此时输出-1即可。

## 遇到问题



## 复杂度分析

1. 在并查集中，采用了路径压缩和按秩合并，因此复杂度可以达到$n\times$反阿克曼函数。

   在左式堆中，合并所需要的复杂度为$O(\log N)$，N是当前合并的堆的结点个数；在删除时，将根的左、右孩子进行了合并，因此复杂度同样为$O(\log N)$。这样，每一次合并最多的操作是将两个满的堆进行合并,此时需要的复杂度$O(k\log k)$.最多有$n/k$这样的堆,因此最多合并$n/k$次,总复杂度$O(n\log k)$.

   最多查询q次,每次查询复杂度$O(1)$.因此总共复杂度$O(n\log k +q + n\alpha(n))$.

2. 并查集所需空间复杂度$O(n)$.对于左式堆,所有的结点不会超出最初的所有堆,也即最初结点数n,因此其空间复杂度也为$O(n)$.因此总体的空间复杂度$O(n)$.

