# Not Found

## 设计思路

由于01串很长，最长可以到达2^24^，因此采用位图的数据结构，这样一共2^21^位2MB就可以将整个字符串存下来。

根据题意，我们可以发现，当字符串长度位n时，$\lceil\log_2n\rceil$长度的01串中一定有不存在于字符串中的。对于题目中的长度，$\lceil\log_2n\rceil=24$，那么最小的不存在的字符串最长为24。

为了找出在串中不存在的最小的子串，采用了字典树。建立高度为25的字典树，也用位图的方法来储存，这样4MB就可以将整棵二叉树储存下来。在储存下来的字符串中从头开始，按24长度不断将字串所代表的值插入到字典树中，并将路径上的点都改为存在。在将所有的字串都插入到字典树后，从头开始寻找第一个不在字典树中的结点序号，则此结点所对应的路径的串就是在源字符串中不存在的最小的子串。

## 遇到问题

1. 在最初的字典树，如果从根向树叶一个个放入字典树，则每次需要$O(24)$的复杂度，常数有点大。如果更新了加入的方法，直接定位到结点的序号，就可以减少常数，符合时间的限制。

## 复杂度分析

1. 读入字符串的操作时间复杂度为$O(n)$。在建树后，每一次按照字串定到字典树的位置为$O(1)$，并不断向上更新。这些非树叶结点每个最多被更新1次，因此更新的总体复杂度为$O(n)$。最后将树中的结点依次遍历来寻找第一个不存在的结点，查找的长度不超过$O(n)$。因此总体复杂度为$O(n)$，可以满足题意。
2. 空间复杂度储存字符的空间复杂度为$O(n)$。最多为$2^{24}/2^3=2^{21}$，2兆空间即可储存。字典树的空间复杂度也为$O(n)$，最多需要的空间$2\times2^{24}/2^3$，4兆空间即可储存。因此总体$O(n)$，在6MB可以储存下来，符合题目要求。

