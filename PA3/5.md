# Prefix

## 设计思路

为了统计每一个前缀的出现次数，利用KMP算法中的`next[]`数组来辅助计数。当`next[i]=j`不为0时，代表长度为j的前缀在$(i-j,i-1)$这里又出现了一次，将总共的次数加1。

同时，有可能在长度为j的前缀在i处出现的同时，同时有长度较短，且不能更长的k的前缀也在第i处出现$(i-k,i-1)$。如果这种情况出现，那么长度为k的前缀是长度为j的前缀的后缀，即k=next[j]。以次类推，同理可得，在`next[next[...next[j]]]`直到0过程中出现的非零整数所代表的前缀都在这里出现了一次。因此统计下这些非零整数的个数，都加到答案中，就可以得到正确答案。

将`next[next[...next[j]]]`的所有的非零整数的个数为`cnt[j]`，则可以采用动态规划的方式来求解。`cnt[j]`满足状态转移方程`cnt[j]=cnt[next[j]]+1;`这样只需要从头开始，将每一个k更新一遍即可获得`cnt[j]`；再从头开始将这些加起来，并考虑到每个前缀本身出现的次数，便可以得到最后的解。

## 遇到问题

1. 在最初采用了类似于递归的方式,每一次不断取`next`直到到0,但这样的方式在最坏`aaaaaaa...a`可以达到$O(n^2)$的时间复杂度.正确的方式是采用动态规划,在$O(n)$的时间内即可初始化完成,之后就可以直接利用以前的结果.

## 复杂度分析

1. 在时间复杂度上,计算next数组时间复杂度为$O(n)$.在此基础上计算cnt数组时间复杂度同样为$O(n)$.在计算出该数组后再加起来同样也是$O(n)$,因此整体在$O(n)$的复杂度中就可以完成.
2. 在空间复杂度上,由于程序基本上只采用了数组,因此空间复杂度都为$O(n)$,满足题意要求.