# Graph

## 设计思路

### 算法设计

- 首先，由于要计算最短路径的个数，因此要将所有由边权为0相连的点合并为一个点，这里需要使用并查集，来合并所有点
- 利用Dijkstra算法来计算：从1到各个点的最短路径和最短路径的条数，从n点到各个点的最短路径和最短路径的条数。为记录最短路径条数，只需要增加新的判断条件。
- 在计算增加边后的路径时，根据加上的边的边权来进行判断。设加入边边权$w$，连接点$u,v$。若$dis[u]=dis[v]$，则加入边后总不会构成新的最短边。若$dis[u]<dis[v]$时，$(1,v),(v,u),(u,n)$总不会是最短路，而$(1,u),(u,v),(v,n)$可能构成最短边；$dis[v]<dis[u]$时同理。因此只需要判断$u,v$中离1较近的点（不妨记为$u$）$dis[u]+dis[v]+w$与$dis[n]$的大小：较大时只需输出原来的条数；相等时，新增加最短路径数$num[u]\times num[v]$；若较小，则新的最短路径条数为$num[u]\times num[v]$

### 数据结构

- 并查集

  ```c++
  class UnionFind{
      int par[maxn];
  public:
      void init(int size);
      int find(int a);
      void merge(int a,int b);
      bool same(int a,int b);
  }
  ```

  实现了初始化、查询等价类、合并等价类和判断是否在同一个等价类的功能

- 堆

  ```c++
  template <class T> class Heap{
      T src[maxm];
      int size = 0;
  public:
      void push(T x);
      T pop();
      T top();
      bool empty();
  };
  ```

  实现了一个堆，用于Dijkstra算法

- 邻接表

  ```c++
  struct Edge{
      int to,cost;
  };
  ```

  边的数据结构

  邻接表利用了`Vector<edge>[n]`来实现

## 问题

1. 在新加入的边$(u,v)$是，未考虑到无向边，直接按照输入的顺序进行了判断，导致会错误；而在增加了判断更靠近1号点的点后就可以了。
2. 数据范围可能到很大，要及时取模，并对最短路径的长度等量采用范围更大的数据类型即可。

## 复杂度分析

1. 时间复杂度：Dijkstra算法在使用堆后时间复杂度$O(n\log m)$，每次输入新的边查询时间为常数$O(1)$。因此总体时间复杂度为$O(n\log m+q)$，可以在时间限制内完成。
2. 空间复杂度：在储存邻接表的过程中，每条边被储存两遍，储存空间复杂度$O(m)$；在并查集的实现中，每个结点一个，复杂度为$O(n)$；在Dijkstra算法使用的堆中，每个边最多被加入一次，因此复杂度$O(m)$；储存最短路径长度、条数的数组复杂度也为$O(n)$。因此总体空间复杂度$O(m+n)$，可以满足空间限制。

