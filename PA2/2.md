# Circuit

## 设计思路

为能够快速地求出两个元件的异或值，采用字典树的方法，以树的左/右孩子来代表元件中的0/1，这样以贪心的走法在树上，如果可以就向0/1相反的方向走，如果不行就走1/0，这样就可以判断出异或最大值的元件。

#### 数据结构

```c++
struct node{
    int sum;
    int lc, rc;//向左为0
    node():sum(0),lc(0),rc(0){}
};
```

结点中储存了左儿子、右儿子的秩和变量`sum`，这是通过当前结点的元件个数。

```c++
struct leaf{
    int sum; listNode* head, *tail;
    leaf(){head = new listNode(-1); tail = new listNode(-1); head->nxt = tail; tail->pre = head;}
}；
```

在树叶节点中加入了一个列表，用于储存这里的所有元件的个数。

#### 算法实现

1. 插入/删除

   按照元件的序列，按0/1分别向左/向右走，并将结点的`sum`加一，并在树叶的链表中插入/删除这个元件的序号

2.  查询

   按照元件的01序列，按照贪心的方法向下查询，如果可以就向0/1相反的方向走，如果不行就走相同的方向（因为本身一定在，所以一定有路径可以走），最后在树叶出读取链表中的第一个，如果是自身就读第二个，这就是结果

3. 整体

   根据所给的查询范围，不断向右移动，插入新到范围的、删除离开查询范围的，并进行查询，就可以得到结果。

## 问题

1. 最初看提示也想不出来和二叉树什么关系，后来听了习题课、查询了资料才知道...


## 复杂度分析

1. 时间复杂度上，每次查询、插入、删除的时间复杂度都为$O(1)$常数时间。而每个元件都会进行最多一次插入、删除、查询，因此总体时间为$O(n)$，可以在时间限制内完成；
2. 空间复杂度上，树的最多结点的下界可以确定为2^20^+n*44$=O(n)$；而树叶结点的链表中增加的空间复杂度为$O(k)$。因此总体可以在空间限制内完成。