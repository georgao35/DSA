# Build

## 设计思路

整个题目中实现了一个多叉树，维护了结点的高度和子树的规模。

### 数据结构

结点：每个结点用序号代替存储在数组中。

```c++
struct Node{
    int parent, nextSibling, prevSibling, firstSon;
    int height, scale;
}
```

每个结点存储父亲结点的秩、第一个最左侧的儿子的秩、下一个（右侧）兄弟的秩和上一个（左侧）兄弟的秩。`scale`储存了子树的规模。`height`储存了左侧孩子`height+1`与右侧兄弟`height`的较大值。则当前结点的高度为`firstSon`的`height+1`，可以在$O(1)$时间取得当前结点的高度。以秩0为哨兵，代表不存在的结点。

### 算法实现

#### 建树

按照顺序将结点与父亲、相邻的兄弟进行连接，并从根开始初始化高度和规模

#### 通过路径获取结点

按路径长度，当下一个数字是$r$时，先取当前结点的`firstSon`，在从此开始向后取$r$次`nextSibling`。若此时的结点仍存在，则以此结点继续向下寻找；若结点不存在，则当前的结点即为最后的目标节点，返回值即gengxin可。在此过程中，每一层寻秩的复杂度都不超过秩的大小；因此总共的过程不超过每一次的cost。

#### 更新规模

切割/插入子树后，不断更新父亲结点的规模，减去/加上移动的子树的规模。更新规模的操作不超过移动结点位置的cost。

#### 更新高度

切割/插入后，从当前结点不断向左更新各节点的`height`，当没有`prevSibling`后更新父亲，再不断按次规则更新`height`，最终到达树根。更新高度走过的路径是逆向获取结点，操作不超过`cost`。

#### 插入、切割子树

由于每一层的结点实际上构成了一个链表，因此插入、切割的操作和链表的方法相同。

## 遇到问题

1. 在初始化高度和规模时，由于规模较大，因此直接函数递归调用时会发生爆栈的错误

   解决方案：写了一个大小可以到n的栈，利用栈压入更新到的结点来通过循环（`initHeight(),initSize()`）来实现递归初始化高度、规模。

## 复杂度分析

1. 在建树和初始化高度、规模过程中，每次每个结点被遍历一次，因此在此过程中整体复杂度为$O(n)$
2. 在查询过程中，定位结点的过程操作不超过cost，而获取高度和规模只需要$O(1)$时间，因此为$O(cost)$时间
3. 在移动子树的过程中，定位的过程不超过起点和目的节点的cost，切割和加入的操作$O(1)$操作，维护高度和规模的操作不超过两次cost之和，因此移动子树的复杂度复杂度$O(cost)$
4. 因此总共的复杂度为$O(n+\sum cost)$，可以在时间限制内完成
5. 整体的空间复杂度为$O(n)$

