<h1><center>pa2 BBST Performance Analysis</center></h1>

<center>计92 2019011230 高敬越</center>

### 数据结构的实现过程

实现了AVL树和splay树两种数据结构。首先实现了二叉搜索树的基类，再继承了二叉搜索树实现了AVL和splay树，实现了AVL的调整和splay的伸展过程。

### 复杂度分析

#### AVL树

1. 在搜索时，由于AVL树可以保证适当平衡，即使临界的时候能保持$n = S(h)=fib(h+3)-1$，因此每次搜索都可以在$O(h)=O(c\log n)$时间内完成。
2. 在插入时，首先搜索到应当插入的位置，搜索的复杂度为$O(c\log n)$。在以$O(1)$复杂度插入后，不断向上检查当前结点是否平衡。若不平衡，则会在此处进行调整，调整的过程为$O(1)$，并且最多只需要一次调整；不平衡时只需更新高度，以便判断平衡。因此整个插入过程的最差复杂度为$O(c\log n)$。
3. 在删除时，首先搜索被删除的结点，存在时进行删除$O(1)$，并在删除后一直向上，并不断调整平衡并更新高度。此时需要做$\Theta(\log n)$复杂度来调整。

整体上看来，可以看出AVL树可以借助记录的高度，使每次的插入/删除/搜索等操作均保持到$O(\log n)$。而调整时仍需要花费，最坏时平均概率为0.21次。

#### Splay树

与AVL树不同，伸展树在每次访问一个点后便会将该点伸展至树根处。对于插入、删除、删除和伸展的操作，从均摊上来说，可以得到分摊的复杂度为$O(\log n)$。当所查询的局部性强且命中率高时，每次查询甚至可以达到常数复杂度$O(1)$；但当查询的数据相差过大或者无法命中时，查询的性能将较低，甚至可以达到最差的复杂度$O(n)$。

### 设计测例的思路

针对不同的特点，设计了3组不同的测例：

1. 按大小顺序插入随机生成数据，后在小范围内随机查找，以测试在splay树适用的数据特性中的表现，数据范围1500000；
2. 按大小顺序插入随机生成的数据，后在所有数据范围中随机查找，可以测试splay树的查找和伸展操作在随机表现下的整体均摊复杂度，数据范围1500000；
3. 完全随机生成的数据。在前一部分插入后，剩余随机插入、删除、查询随机的数字，用来测试整体的均摊复杂度，数据范围1000000；

### 不同测例下的性能表现

测试采用了对拍工具，并在其中进行计时。avl和splay树的源文件均采用编译指令`g++ *.cpp -o * -O2`编译，运行于Windows 10 wsl，处理器AMD R7-4800，16G内存。

三种测例可以分别通过调用makedata.cpp生成器中的`splay1()`,`splay2()`,`avl()`三个函数进行生成，在test文件夹中提供了三个测例的例子`input1.txt`，`input2.txt`，`input3.txt`。

对于每种测例，均用测例生成器生成30组测例进行测试，取得平均值作为两种数据结构在此类数据结构的用时。测试时不进行输出。对于读入和测试程序调用的时间，整体测试得到一千万个数据需要耗时0.120s，一千五百万耗时约在0.138秒。

可以得到，对于三种测例，两种数据结构的耗时分别为（原始的测试数据可见raw data.md）：

|      | AVL               | Splay             |
| ---- | ----------------- | ----------------- |
| 1    | 0.332-0.138=0.194 | 0.281-0.138=0.143 |
| 2    | 0.527-0.138=0.389 | 0.557-0.138=0.419 |
| 3    | 0.911-0.120=0.791 | 1.53-0.120=1.41   |

通过数据可以推断，在完全随机的样例中，splay的均摊复杂度仍为$O(\log n)$，但是相较于avl树来说，可能由于插入、删除及搜索时的伸展等原因，整体复杂度的常数较大，耗时接近两倍。通过对所有数据进行排序，消除掉插入时的伸展因素时，可以测得：若能保持数据一定的有序性，减少插入、删除等操作中的延展，复杂度可以降低，但此时树的形态不好，而AVL可以通过一定的调整来使高度降低。若还能同时使测试查找的数据在很小的范围中，则可以进一步减少查询时的查询深度，查询的复杂度可以继续降低，获得比avl树更好的性能。

由此可见，不同的数据结构在不同的情境下有不同的复杂度。不同的数据结构都有其适用的背景和条件。对于avl和splay树，在适用于splay树的查询范围小等条件时可以选用splay树，对于完全随机等均摊的测例下使用avl是更好的选择。