# A+B problem

## 数据结构与算法设计

程序采用了高精度模拟竖式的计算方法。但是与手算时的10进制进行计算时不同，程序以10^8^为单位进行乘法和进位。数据结构上，利用`getInt()`将长整数按$10^8$进制储存为无符号长整数`unsigned long long`数组`IntA[1000]`和`IntB[1000]`，用数组`result[2000]`储存计算的结果。两数相乘的结果位数一定不会超过乘数位数之和。因此计算原理为：位数`i`从低至高（从0开始到`alen+blen`），按算式$result[i] = \sum_{0\le j\le alen,0\le k\le blen,j+k=i}a[j]\times b[k]$计算`result[i]`的值，且当$i\ge1$时要加上前一位进位的值`result[i-1]%100000000`。最后按8位长度（最高位除外）依次输出各位的值，以便补充中间位数的开头的0。

## 问题与解决

1. 进制的选择

   在最初，采用了10进制进行储存和计算，但这样导致复杂度尽管仍在$O(n^2)$，但是没用利用好c++本身的整数乘法，导致常数过大，仍然会超时。在不断增加的过程中，进制越大所需的操作越少，但同时也遇到了产生溢出等问题。最后经估算，采用10^8^与unsigned long long时可以符合效率与正确性的要求。

2. 边界情况的处理

   在最初处理边界情况时出现问题。在乘法中，可能会出现0为乘数的情况，此时在寻找结果数组`result[]`中的值都为0，因此在寻找结果的最高位时要防止找到负数，产生一个随机的错误答案。在增加了一个判断条件后解决了这个问题。

## 复杂度估计

在初始化、将输入字符串转换为整数组的操作中，所有函数的时间、空间复杂度都为$O(n)$。

在运算过程中，求第$i$位的数值需要进行$min(i,alen-i,blen-i)$次操作，因此总共需要进行$O(n^2)$级的空间复杂度和$O(n)$的空间复杂度；而在采用了更高的进制后，可以大幅降低$alen,blen$的值，时间复杂度可以变为$O(n^2/k^2)$，k是采用的进制大小。

综上，时间和空间复杂度分别估算在约$O(n^2),O(n)$量级。

