# filename

## 设计思路

题目中所求为一个字符串改为另一个字符串所需要的最小的更改次数。而所需要的更改次数d与两个字符串最长公共子序列有关，即更改次数d满足$d = m+n-2\cdot LCS$，其中m，n是两个字符串的长度，LCS是最长公共子序列的长度；而求LCS可以使用动态规划的方法，状态转移方程为$f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + (A[i] == B[j]))$，但是仍需要利用题目中的条件进行优化。

### 数据结构

程序利用线性数组`a[],b[]`来储存两个字符串；并用二维数组`d[][]`来储存状态，其中`d[i][j]`代表A的前i与B的前j所具有的最长公共子序列。但是如果将d数组开为`d[m][n]`的话，$O(mn)$的空间复杂度容易导致超过内存限量。但观察状态转移方程后可以发现，在求解$d[i][j]$时，第一个坐标最小只与i-1有关，因此可以采用滚动数组	`d[2][n]`，这样就可以按i的奇偶性不断地滚动0，1来节省空间，按照$f[i \mod 2][j] = max(f[i - 1 \mod 2][j], f[i\mod 2][j - 1], f[i - 1\mod 2][j - 1] + (A[i] == B[j]))$的方程进行转移。

### 算法

在算法上，即使采用了滚动数组，在运算时要经过$mn$次转移，$O(mn)$的时间复杂度也会超时。题目中要求变更的花费小于k，因此可以发现只需要考虑相差k个以内的字符之间的最长公共子序列，当$|i-j|>k$时一定不符合要求，可以不管，则总共的复杂度可以变化为$O(mk)$。

## 遇到问题

1. 时间复杂度过高

   在完成这道题的过程中，在可以优化空间时一直没有找到将时间复杂度降低的方法，一直没法找到可以达到$O(mk)$的状态转移方程；后在习题课中听到了解决方案，发现没有利用好最大花费的条件，在更改后成功通过。

## 复杂度估算

由上文可以得到：空间复杂度为$O(n)$，时间复杂度为$O(nk)$，满足题目中的时间、空间要求。