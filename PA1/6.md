# 9的完美文本编辑器

## 设计思路

根据题目要求，要实现一个支持常数复杂度的移动、插入、删除、反转操作的数据结构，并且在上面实现两个光标。因此程序设计了一个基于游标的类XOR-链表以满足要求。

### 数据结构

程序采用数组来存放所有的链表结点，可以通过数组的索引值访问到链表的结点。链表结点的结构为

```c++
struct Node{
    int sum;//储存结点前后结点的数组的索引值之和
    char data;//结点的值
} nodes[8000000];//用于储存所有结点的数组
```

与普通的双链表分别存储前一位索引、后一位索引不同，在程序中，链表的结点存储前驱和后继结点的索引之和。这样，在已知当前结点及其前驱/后继时，就可以在$O(1)$的时间内知道其后继/前驱的位置。程序也实现了`getSucc(int pred, int now)`以及`getPred(int succ, int now)`函数来完成这一工作。因此整个链表的操作与普通双向链表相同，只是需要提前获取一下前驱/后继的索引值。

同时，链表也增加了头结点和尾结点，分别位于数组的第1、0个结点。

### 功能实现

#### 光标

在光标的实现上，程序采用了类似于终端中占一字宽的光标的实现方法，光标位于一个结点上，插入时插入到左侧，删除时删除当前所在的结点，最终可以表现出题目中要求的功能。因此程序以数组的方式记录了`cursor[2]`，分别记录了左光标`cursor[0]`和右光标`cursor[1]`所在的结点的索引；同时，为了确定方向，也用数组`cursorPrev[2]`来记录光标的前驱的索引。为了后面功能的实现，也记录了光标在字符串中的位置`cursorId[2]`。

#### 左/右移

在左右移动时，首先判断是否可以左/右移。判断是否左/右是否越界的方法是判断光标当前是否与第一个字符/尾结点重合。若可以移动，由于已知当前索引以及前驱的索引，因此可以求得前驱的前驱的索引以及后继的索引，可以方便地进行更新，光标成功移动。同时更新在字符串中的位置。

#### 插入

插入的操作与普通链表相同，插入后仍要判断在数组中的位置是否需要更新。

#### 删除

删除时首先判断是否可以删除，判断方法是判断光标是否在最右侧。判断后可以直接按照链表的方式删除，并按情况对光标在字符串的位置进行更新。

#### 反转

首先判断是否可以反转，是通过两光标在字符串中的相对位置进行判断的：只有当右光标的位置在左光标右侧时才会反转。由于结点储存的是前驱和后继的和，因此中间的结点都不用进行操作，只需要将光标及其前驱的相连关系进行更改，便可以完成反转操作。

#### 显示

显示时通过从头开始遍历所有结点便可以显示字符串。

## 遇到的问题

1. 反转操作的时间复杂度

   在最初使用双向链表时，复杂度始终无法降为$O(1)$，并且对于习题课的方法没有看懂，后来经过搜索学习到了XOR链表的操作，成功将复杂度降低

2. 在各个操作的编写中经常少操作了`cursorId[]`等变量，没有考虑全面，导致出现了错误。后来对于各个函数进行了仔细地阅读分析，才发现是少了一个更改位置的语句造成了RE等错误。

## 复杂度分析

在空间上，程序开辟了足够所有操作都在插入结点的空间，复杂度在$O(n)$。

在时间上，除了S指令外的其他所有操作都在常数时间内就可以完成，复杂度均为$O(1)$，整体所有操作时间复杂度$O(n)$；对于展示操作尽管单次操作复杂度$O(n)$，但由于题目中给出输出文件大小小于20MB，因此是符合时间要求的。

