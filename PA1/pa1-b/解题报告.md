计92 高敬越 2019011230

## 01

1.错误类型：Runtime Error

2.错误原因：在递归调用play函数`play(left - 1);`以检查是否有连续消除的情况时，没有保证`left-1`是大于0的，这样在下一层递归调用中出现`rank=-1`，出现访问非法地址的错误。

3.相应测例：

```
AABB
1
0 A
```

正确答案：

```
BB
```

4.构造思路：只需要构造一个可以在开头消除的测例，这样在消除后就会调用`play(-1)`，产生错误

## 02

1.错误类型：Time Limit Exceeded

2.错误原因：string类的erase、insert方法的复杂度均与生成的子串长度成大概的线性关系，因此整体的复杂度在最坏情况下可以达到$O(m^2)$，造成超时的错误。

3.相应测例：

```
EFEF...EF(长49980)
49980
0 A
0 A
0 B
0 B
...(循环)
```

4.构造思路：不断向已经足够长的序列的最前端增加字符，使程序超时

## 03

1.错误类型：Time Limit Exceeded

2.错误原因：同上

3.相应测例：与02相同

4.构造思路：

## 04

1.错误类型：Wrong Answer

2.错误原因：在play函数中判断是否是三个相连时，采用条件`left>0`，使得没有判断最左侧位置为0的字母是否相同；同时left也没有加1，导致得到的size实际上是连续的珠子个数+1，使得长度判断错误，当只有两个相邻的珠子是相同的时候就进行了消除。

3.相应测例：

```
CAB
1
3 B
```

正确答案

```
CABB
```

4.构造思路：只需要构造出一个测例，使得向其中增加后有两个相邻的相同珠子，程序便会错误地消除。

## 05

1.错误类型：Wrong Answer

2.错误原因：程序采用了cin输入，当原始的字符串为空时不能读进a去，会将m的值读进去，以后的也将错位，导致出现WA

3.相应测例：

```

2
0 A
0 A
```

​	正确答案：

```
AA
```

4.构造思路：只需要构造初始序列为空的测例

## 06

1.错误类型：Time Limit Exceeded

2.错误原因：虽然使用了由链表相连接的长度为$O(\sqrt{n})$的向量作为数据结构，但是在程序运行过程中，不同向量之间没有进行重新的编排，因此插入、删除等操作的复杂度无法保持在$O(\sqrt{n})$，而是$O(l)$，其中l是每块向量的长度。一块向量可以不断插入，每次插入与当前向量长度成线性，因此复杂度可以达到$\sum_ii\approx O(m^2)$，会超时。

3.相应测例：

```
ABABABA...ABAB(长500000)的初始字符串
500000
0 C
0 D
0 E
0 F
...（不断循环）
```

正确答案：

```
FEDCFEDC...FEDCABAB...ABAB
```

4.构造思路：不断对一个块进行插入操作，使其超时

## 07

1.错误类型：Runtime Error

2.错误原因：head、tail在移动过程中经常移动到-1位置或者开头、结尾的哨兵结点，而访问时没有对此时的索引进行判断，访问非法位置，因此`operator[]`函数没有返回值，造成RE。

3.相应测例：

```
ABABABEFFEE
1
8 F
```

正确答案

```
ABABAB
```

4.构造思路：让连续相消的部分位于结尾，使得程序访问非法位置，`operator[]`无返回值，产生Runtime Error。

## 08

1.错误类型：Wrong Answer

2.错误原因：在确定消除范围[head,tail)时，如果消除的头和末尾在同一个分块上的话，没有将head右移的操作，导致消除的时候多消除了一个。

3.相应测例：

```
AABCCDDEFFEDGHUJ
1
6 D
```

​	正确答案：

```
AABCCEFFEDGHUJ
```

4.构造思路：构造一个序列，使得在分块中间出现两个相邻的同色（在这里是CDDE），并向其中增加一个D，这样程序就会把最后一个C也清除，产生错误答案AABCEFFEDGHUJ。

## 09

1.错误类型：Wrong Answer

2.错误原因：在程序122行开始，play函数消除中间的连续部分中，程序未考虑到左、右边界同时在一个分块中的情况，直接将左边界所在块的长度设置为`plen[l.first] = l.second + 1;`。这样运行到右边时，剩余的长度将为 plen[r.first] - r.second = l.second + 1 - r.second$\leq-3$，使得记录的长度出现错误。而在之后仍可以向这个块中增加元素，当增加足够多后plen为正，仍可以正常输出，造成WA。

3.相应测例：

```
AABBCCDEFGHY
5
3 B
1 X
1 Y
1 Z
1 O
```

​	正确答案：

```
AOZYXACCDEFGHY
```

4.构造思路：首先构造出初始字符串并通过加入B，造成错误的消除过程，并使记录中的长度变为-3；之后再增加4个元素，使得记录下来的长度变为正数，正常输出错误答案。

## 10

1.错误类型：Wrong Answer

2.错误原因：边界的更新出了问题。在程序从第116行开始消除相连的球。其中，在相连的球横跨多个块，即左、右边界在两块数组的情况下，程序运行到第132行处、将r置为l后直接将`r.second`加1，并没有将r实际放到下一个相邻的块上。此时，r实际的位置超越了当前数组块的逻辑边界，在内存中则是刚刚消除的球的位置，这样字符一定与l所指向的字符及真正的下一个字符不同，可能会检查不出$AABBA$样式的连消情况。

3.相应测例：

```
EFEFEF...E(占位用字符，有2045个)AABBAXYXYXY...XY(在总字符不超过界限的情况下任意)
1
2048 B
```

正确答案：

```
EFEFEF...EXYXY...XY
```

4.构造思路：构造一个测例使得有两个相同的字符恰好在第一个分块数组的最后和第二个分块数组的首位，同时让它们左、右有相同的字符可以构成连消；而程序中的初始分块大小为`1<<11`，因此构造出测例使得第2046、2047位为字符A，2048、2049位为字符B，2050位为A，其余字符选择其他字母。