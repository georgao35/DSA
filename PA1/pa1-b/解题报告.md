## 01

1.错误类型：Runtime Error

2.错误原因：在递归调用play函数以检查是否有连续消除的情况时，没有保证`left-1`是大于0的，这样在下一层递归调用中rank=-1，出现访问非法地址的错误。

3.相应测例：

```
AABB
1
0 A
```

正确答案：

```
BB
```

4.构造思路：只需要构造一个可以在开头消除的测例，这样在消除后就会调用`play(-1)`，产生错误

## 02

1.错误类型：TLE

2.错误原因：

3.相应测例：

4.构造思路：

## 03

1.错误类型：TLE

2.错误原因：

3.相应测例：

4.构造思路：

## 04

1.错误类型：Wrong Answer

2.错误原因：在play函数中判断是否是三个相连时，采用条件`left>0`，使得没有判断最左侧位置为0的字母是否相同；同时left也没有加1，导致得到的size实际上是连续的珠子个数+1，使得长度判断错误，当只有两个相邻的珠子是相同的时候就进行了消除。

3.相应测例：

```
CAB
1
3 B
```

正确答案

```
CABB
```

4.构造思路：只需要构造出一个测例，使得向其中增加后有两个相邻的相同珠子，程序便会错误地消除。

## 05

1.错误类型：Wrong Answer

2.错误原因：采用cin输入，当原始的字符串为空时不能读进a去，会将m的值读进去，以后的也将错位

3.相应测例：

```

2
0 A
0 A
```

​	正确答案：

```
AA
```

4.构造思路：只需要构造初始序列为空的测例

## 06

1.错误类型：Time Limit Exceeded

2.错误原因：虽然使用了由链表相连接的长度为$O(\sqrt{n})$的向量作为数据结构，但是在使用中不同向量之间没有进行重新的编排，因此插入、删除等操作的复杂度无法保持在$O(\sqrt{n})$，而是$O(l)$，其中l是每块向量的长度。一块向量可以不断插入，每次插入与当前向量长度成线性，因此复杂度可以达到$\sum_ii\approx O(n^2)$，会超时。

3.相应测例：

```
ABABABA...ABAB(长500000)的初始字符串
500000
0 C
0 D
0 E
0 F
...（不断循环）
```

正确答案：

```
FEDCFEDC...FEDCABAB...ABAB
```

4.构造思路：程序按照$\sqrt{len}$len为初始字符长度进行分块后，不断进行插入操作，使其超时

## 07

1.错误类型：RE

2.错误原因：

3.相应测例：

4.构造思路：

## 08

1.错误类型：Wrong Answer

2.错误原因：在确定消除范围[head,tail)时，如果消除的头和末尾在同一个分块上的话，没有将head右移，导致消除的时候多消除了一个。

3.相应测例：

```
AABCCDDEFFEDGHUJ
1
6 D
```

​	正确答案：

```
AABCCEFFEDGHUJ
```

4.构造思路：构造一个序列，使得在分块中间出现两个相邻的同色（在这里是CDDE），并向其中增加一个D，这样程序就会把最后一个C也清除，产生错误答案AABCEFFEDGHUJ。

## 09

1.错误类型：Wrong Answer

2.错误原因：在play函数消除中间的连续部分中，程序直接将左边界所在块的长度设置为`plen[l.first] = l.second + 1;`，未考虑到左右边界在同一个块中的情况。这样运行到右边时，剩余的长度将为 plen[r.first] - r.second = l.second + 1 - r.second$\leq-3$，使得记录的长度出现错误。而在之后仍可以向这个块中增加元素，当增加足够多后仍可以输出错误答案，造成WA。

3.相应测例：

```
AABBCCDEFGHY
5
3 B
1 X
1 Y
1 Z
1 O
```

​	正确答案：

```
AOZYXACCDEFGHY
```

4.构造思路：首先构造出初始字符串并通过加入B，造成错误的消除过程，并使记录中的长度变为-3；之后再增加4个元素，使得记录下来的长度变为正数，正常输出错误答案。

## 10

1.错误类型：Runtime Error

2.错误原因：

3.相应测例：

4.构造思路：
