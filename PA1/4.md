# Risk

## 设计思路

题目中要求的重点是求出向前追溯的几天内的最大确诊数值，因此考虑采用queap数据结构，来取出前几天的最高确诊数目。

### 数据结构

queap的结点结构设计如下

```c++
struct Node{
    Node* pred,* succ; int data;int count;
    Node():count(1){}
};
```

`pred`和`succ`两个指针代表了列表结点的前一个结点和后一个结点，`data`是结点中储存的测试，`count`是最大值为data的天数；同时定义了两个Node*变量`queapH`,`queapT`来代表queap的头和尾。

为queap实现了`push(int)`和`pop()`函数，分别用来将数据加入queap和将queap头上的最大值弹出：

1. `push(int data)`函数的实现为将data从后往前进行比较，直到有结点的数值大于插入的数值data，且更新新结点的count为之前所有较小结点的count之和，并删除之前较小的结点。
2. `pop()`函数的实现为从queap的头结点中取出最大值，将count减一，并且当count变为0时弹出最早的结点

其余的数据如每一天的确诊数量用数组`x[]`、每一天追溯的结果用数组`result[]`来进行储存。

### 算法设计

程序的算法大致如下：

1. 读入所有的每日确诊人数
2. 读入每天向前追溯到的天第i天，将queap中第i天之前的所有天都弹出`pop()`，获取该天的结果（通过`queapH->succ->data`），放入result中，再将这一天的数据`push(int)`加入到queap中
3. 在获取了每一天的结果后，来判断高中低风险的天数，采用二分查找的方法来进行查找
   1. 首先将所有的result用归并排序的方法进行排序
   2. 再利用二分查找的方法在排序后的数组中进行查找$p_i,q_i$，查找到的位置就能代表在0$\sim p_i/q_i$范围内的天数，进而就可以得到低风险、中风险的天数，最后就可以输出了

## 遇到的问题

1. I/O太耗时

   在程序中，即使改用了`scanf()`与`printf()`函数进行操作后仍然在超时的边缘徘徊，但我经过多种测试后仍然不能有效的减少时间；但经过网络查找资料后，学习到了经典的快速读入模板，在使用后大大地提高了程序运行地效率

2. 数据范围

   在题目中，尽管确诊数据、总共的日期都在10^6^范围内，但是追溯的天数m和阈值p和q都超过了int范围，达到了unsigned int 的范围。因此在处理中，由于类型转换和对无符号类型不够熟悉，在判断大小和进行减法时发生了错误（如与无符号整数减出负数时会下溢为很大的数），造成11点RE等错误。在充分利用了递增等条件后，解决了这一问题。

## 复杂度估计

在空间复杂度上，整体都采用了线性结构，空间复杂度为$O(n)$

在时间复杂度上，归并排序的复杂度为$O(n\log n)$，所有的二分查找总耗时为$O(T\log n)$；在queap的操作中，尽管插入的最坏情况可以到$O(n)$，但是对于每一天，都只会进/出一次，均摊下来每次操作都为$O(1)$，总体下满足题目的时间要求。

